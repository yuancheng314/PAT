#include <cstdio>

int main()
{   char signal,A[100001]={0}; 
    /* 题目说到底数的大小不超过9999字节，另用1个字节
       A[0]存储符号,最后一个字节存储结束标识符'\0'，
       故A的大小最小为10001，是否初始化为0没必要。       
    */
    int  index=0;
    scanf("%c%c.%[0-9]E%d",&signal,&A[0],A+1,&index); 
    /*将读入拆分为三部分，数组用于存储底数部分的所有数字
    (包含整数、小数点后的有效数字)，index用于存储指数，singnal
    用于存储该数本身的正负（在随后的一个判断中，若符号为-则直接输出，
    若符号为+,无需单独处理）
    */
    if (signal=='-') {  printf("-");}
    if (index>0)
    {   for(int i=0;i<=index||A[i]!=0;i++) 
        {   if(i==index+1) { printf("."); }
            printf("%c",A[i]==0 ? '0': A[i]);
        }
        /* 第18-20行代码不太好理解,先从将科学计数表示为普通数字本身来思考：
        当指数大于0时，也即最终数字会在底数的基础上放大，这便存在两种情况，
        1.如果放大的倍数很大，那么底数最终会是一个整数（也就不再需要输出小数点）
        2.放大的倍数不能是底数丢掉小数点
        那么，该如何判断是否会输出小数点呢？
        回到代码，第18行循环条件为还没输出指数那么多位或者A[i]!=0(也即底数中
        的所有数字还没输出完)　注意：A中保存的是char类型元素，故这里的0为ascii码
        为0也即'\0' 
        第19行，如果i比指数大了，而循环仍在继续，则说明，放大的倍数
        不足以丢掉小数点，此时需要输出小数点。　
        第20行，很容易出错，注意到Ａ中保存的是char类型，如果Ａ中元素ascii码为０，则不会
        再输出，所以需要在判断Ａ中元素已经输完之后输出０（数值上的０），如果Ａ中元素没有
        输完，直接输出A[i]即可。
        

        */

    }
    else
    /*若指数小于０，则最终结果一定小与１，故先直接输出0.
      接下来，还需要输出两部分，一是最终输出的数比原来的数
      多出来的0,共有(-index)-1个，二是原有的所有数字。  
     */
    {   printf("0.");
        for(int i=1;i<=(-index)-1;i++)
            {   printf("0");    }
        printf("%s",A);

    }

    return 0;
}